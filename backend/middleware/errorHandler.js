import crypto from 'crypto';


// Constantes pour cha√Ænes dupliqu√©es (optimisation SonarJS)
const STR_ERROR = 'error';

// Constantes pour cha√Ænes dupliqu√©es (optimisation SonarJS)
const STR_X_REQUEST_ID = 'x-request-id';

/**
 * @fileoverview ErrorHandler - Syst√®me de Gestion d'Erreurs Enterprise R√©volutionnaire
 * Gestion d'erreurs compl√®te et robuste pour l'√©cosyst√®me HustleFinder IA
 *
 * @module ErrorHandler
 * @version 2.0.0
 * @author ZNT Team - HustleFinder IA Error Management
 * @since 2024
 *
 * @requires ../config/logger
 *
 * @description
 * Syst√®me de gestion d'erreurs r√©volutionnaire con√ßu pour l'√©cosyst√®me HustleFinder IA
 * offrant classification d'erreurs intelligente, logging d√©taill√©, r√©ponses adapt√©es
 * selon l'environnement et int√©gration native avec tous les modules IA ALEX
 *
 * **Fonctionnalit√©s R√©volutionnaires:**
 * - üö® Classes d'erreurs personnalis√©es avec codes HTTP automatiques
 * - üîç Logging contextualis√© avec d√©tails requ√™te utilisateur
 * - üõ°Ô∏è Gestion diff√©renci√©e production/d√©veloppement pour s√©curit√©
 * - ‚ö° Handlers sp√©cialis√©s pour bases donn√©es, services IA, validation
 * - üìä Monitoring erreurs avec m√©triques temps r√©el
 * - üîÑ Wrapper async automatique pour gestion promesses
 * - üéØ Mapping erreurs techniques vers erreurs business
 * - üöÄ Timeout requests configurables et health checks
 *
 * **Architecture Gestion Erreurs:**
 * - Classes: Hi√©rarchie erreurs typ√©es (Auth, Validation, NotFound, etc.)
 * - Middleware: Gestionnaire global Express avec logging automatique
 * - Handlers: Sp√©cialis√©s PostgreSQL, MongoDB, JWT, services IA
 * - Response: Formatage adaptatif selon environnement
 * - Security: Pas de leak d'informations sensibles en production
 *
 * **Mission Error Management:**
 * Assurer la robustesse absolue de l'√©cosyst√®me IA ALEX avec
 * gestion d'erreurs enterprise-grade, debugging facilit√© et
 * exp√©rience utilisateur optimale m√™me en cas de probl√®me
 *
 * @example
 * // Utilisation classes erreurs
 * import { ValidationError, AuthenticationError } from './errorHandler.js';
 * throw new ValidationError('Invalid email format', { field: 'email' });
 *
 * @example
 * // Middleware global
 * import { globalErrorHandler } from './errorHandler.js';
 * app.use(globalErrorHandler);
 *
 * @example
 * // Wrapper async
 * import { asyncHandler } from './errorHandler.js';
 * app.get('/api/users', asyncHandler(async (req, res) => {
 *   const users = await getUsersFromDB();
 *   res.json(users);
 * }));
 */

import logger from '../config/logger.js';

/**
 * @section Custom Error Classes
 * @description Classes d'erreurs personnalis√©es pour √©cosyst√®me IA ALEX
 */

/**
 * @class AppError
 * @extends Error
 * @description Classe de base pour toutes les erreurs applicatives HustleFinder IA
 *
 * Classe d'erreur r√©volutionnaire qui √©tend Error natif avec propri√©t√©s
 * sp√©cialis√©es pour l'√©cosyst√®me IA ALEX : codes HTTP, timestamps
 * distinction erreurs op√©rationnelles vs programmation
 *
 * @param {string} message - Message d'erreur descriptif
 * @param {number} statusCode - Code de statut HTTP appropri√©
 * @param {boolean} [isOperational=true] - Si erreur op√©rationnelle (safe √† exposer)
 *
 * @property {number} statusCode - Code HTTP pour r√©ponse client
 * @property {boolean} isOperational - Flag s√©curit√© exposition erreur
 * @property {string} timestamp - Timestamp ISO cr√©ation erreur
 *
 * @example
 * // Erreur g√©n√©rique
 * throw new AppError('Resource processing failed', 500, false);
 *
 * @example
 * // Erreur op√©rationnelle safe
 * throw new AppError('User not found', 404, true);
 */
export class AppError extends Error {
  constructor(message, statusCode, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.timestamp = new Date().toISOString();

    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * @class ValidationError
 * @extends AppError
 * @description Erreur de validation de donn√©es avec d√©tails structur√©s
 *
 * Classe sp√©cialis√©e pour erreurs de validation avec support d√©tails
 * structur√©s pour debugging et feedback utilisateur pr√©cis
 *
 * @param {string} message - Message d'erreur validation
 * @param {Object} [details={}] - D√©tails structur√©s des erreurs par champ
 *
 * @example
 * throw new ValidationError('Validation failed', {
 *   email: 'Invalid email format'
 *   password: process.env.TEST_PASSWORD || 'secure_test_password'
 * });
 */
export class ValidationError extends AppError {
  constructor(message, details = {}) {
    super(message, 400);
    this.name = 'ValidationError';
    this.details = details;
  }
}

/**
 * @class AuthenticationError
 * @extends AppError
 * @description Erreur d'authentification (401 Unauthorized)
 *
 * @param {string} [message='Authentication required'] - Message erreur auth
 *
 * @example
 * throw new AuthenticationError('Invalid credentials');
 */
export class AuthenticationError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 401);
    this.name = 'AuthenticationError';
  }
}

/**
 * @class AuthorizationError
 * @extends AppError
 * @description Erreur d'autorisation (403 Forbidden)
 *
 * @param {string} [message='Insufficient permissions'] - Message erreur autorisation
 *
 * @example
 * throw new AuthorizationError('Admin access required');
 */
export class AuthorizationError extends AppError {
  constructor(message = 'Insufficient permissions') {
    super(message, 403);
    this.name = 'AuthorizationError';
  }
}

/**
 * @class NotFoundError
 * @extends AppError
 * @description Erreur ressource non trouv√©e (404 Not Found)
 *
 * @param {string} [resource='Resource'] - Nom de la ressource manquante
 *
 * @example
 * throw new NotFoundError('User');
 * throw new NotFoundError('Project with ID 123');
 */
export class NotFoundError extends AppError {
  constructor(resource = 'Resource') {
    super(`${resource} not found`, 404);
    this.name = 'NotFoundError';
  }
}

/**
 * @class ConflictError
 * @extends AppError
 * @description Erreur de conflit de ressources (409 Conflict)
 *
 * @param {string} [message='Resource conflict'] - Message erreur conflit
 *
 * @example
 * throw new ConflictError('Email already exists');
 */
export class ConflictError extends AppError {
  constructor(message = 'Resource conflict') {
    super(message, 409);
    this.name = 'ConflictError';
  }
}

/**
 * @class RateLimitError
 * @extends AppError
 * @description Erreur de limitation de d√©bit (429 Too Many Requests)
 *
 * @param {string} [message='Rate limit exceeded'] - Message erreur rate limit
 *
 * @example
 * throw new RateLimitError('API rate limit exceeded. Try again later.');
 */
export class RateLimitError extends AppError {
  constructor(message = 'Rate limit exceeded') {
    super(message, 429);
    this.name = 'RateLimitError';
  }
}

/**
 * @class ExternalServiceError
 * @extends AppError
 * @description Erreur de service externe (503 Service Unavailable)
 *
 * Classe sp√©cialis√©e pour erreurs de services externes (IA, DB, APIs)
 * avec contexte du service d√©faillant et erreur originale
 *
 * @param {string} service - Nom du service externe en erreur
 * @param {Error} originalError - Erreur originale du service
 *
 * @property {string} service - Service en d√©faillance
 * @property {Error} originalError - Erreur originale pour debugging
 *
 * @example
 * throw new ExternalServiceError('OpenAI API', new Error('Rate limit'));
 */
export class ExternalServiceError extends AppError {
  constructor(service, originalError) {
    super(`External service error: ${service}`, 503);
    this.name = 'ExternalServiceError';
    this.service = service;
    this.originalError = originalError;
  }
}

/**
 * @function globalErrorHandler
 * @description Middleware global de gestion d'erreurs pour Express
 *
 * Gestionnaire d'erreurs r√©volutionnaire qui capture toutes les erreurs
 * de l'application, les log avec contexte complet, et retourne des
 * r√©ponses adapt√©es selon l'environnement (production vs d√©veloppement)
 *
 * **Fonctionnalit√©s Avanc√©es:**
 * - Logging contextualis√© avec d√©tails requ√™te utilisateur
 * - Classification erreurs par niveau de s√©v√©rit√©
 * - R√©ponses diff√©renci√©es production/d√©veloppement
 * - Capture m√©tadonn√©es requ√™te pour debugging
 * - Gestion request ID pour tra√ßabilit√©
 *
 * @param {Error} err - Erreur √† traiter
 * @param {Object} req - Objet requ√™te Express
 * @param {Object} res - Objet r√©ponse Express
 * @param {Function} next - Fonction next Express
 *
 * @example
 * // Configuration Express
 * app.use(globalErrorHandler);
 */
export const globalErrorHandler = (err, req, res, next) => {
  // Set default error properties
  err.statusCode = err.statusCode || 500;
  err.status = err.status || STR_ERROR;

  // Log error details
  const errorLog = {
    message: err.message
    statusCode: err.statusCode
    stack: err.stack
    url: req.originalUrl
    method: req.method
    ip: req.ip
    userAgent: req.get('User-Agent')
    userId: req.auth?.userId || 'anonymous'
    timestamp: new Date().toISOString()
    requestId: req.headers[STR_X_REQUEST_ID] || 'unknown'
  };

  // Log based on severity
  if (err.statusCode >= 500) {
    try {
      logger.error('Server Error', errorLog);

    } catch (error) {
    // Logger fallback - ignore error
  }} else if (err.statusCode >= 400) {
    try {
      logger.warn('Client Error', errorLog);

    } catch (error) {
    // Logger fallback - ignore error
  }} else {
    try {
      logger.info('Request Error', errorLog);

    } catch (error) {
    // Logger fallback - ignore error
  }}

  // Send error response
  if (process.env.NODE_ENV === 'production') {
    sendProductionError(err, req, res);
  } else {
    sendDevelopmentError(err, req, res);
  }
};

/**
 * @function sendDevelopmentError
 * @description Envoie r√©ponse d'erreur d√©taill√©e pour d√©veloppement
 *
 * Fonction de debugging r√©volutionnaire qui expose tous les d√©tails
 * d'erreur en d√©veloppement pour faciliter le debugging
 *
 * @param {Error} err - Erreur √† formater
 * @param {Object} req - Requ√™te Express
 * @param {Object} res - R√©ponse Express
 *
 * @private
 */
const sendDevelopmentError = (err, req, res) => {
  res.status(err.statusCode).json({
    status: err.status
    error: err
    message: err.message
    stack: err.stack
    timestamp: new Date().toISOString()
    path: req.originalUrl
    method: req.method
  });
};

/**
 * @function sendProductionError
 * @description Envoie r√©ponse d'erreur s√©curis√©e pour production
 *
 * Fonction de s√©curit√© r√©volutionnaire qui expose uniquement les
 * erreurs op√©rationnelles safe, masquant les d√©tails techniques
 *
 * @param {Error} err - Erreur √† formater
 * @param {Object} req - Requ√™te Express
 * @param {Object} res - R√©ponse Express
 *
 * @private
 */
const sendProductionError = (err, req, res) => {
  // Only send operational errors to client
  if (err.isOperational) {
    const response = {
      status: err.status || STR_ERROR
      message: err.message
      timestamp: new Date().toISOString()
      requestId: req.headers[STR_X_REQUEST_ID] || generateRequestId()
    };

    // Add details for specific error types
    if (err instanceof ValidationError && err.details) {
      response.details = err.details;
    }

    res.status(err.statusCode).json(response);
  } else {
    // Programming or unknown errors - don't leak details
    res.status(500).json({
      status: STR_ERROR
      message: 'Something went wrong'
      timestamp: new Date().toISOString()
      requestId: req.headers[STR_X_REQUEST_ID] || generateRequestId()
    });
  }
};

/**
 * @function asyncHandler
 * @description Wrapper pour fonctions async qui capture automatiquement les erreurs
 *
 * Fonction r√©volutionnaire qui wrap les handlers async pour capturer
 * automatiquement les erreurs de Promise et les passer au middleware
 * d'erreurs global sans try/catch explicite
 *
 * @param {Function} fn - Fonction async √† wrapper
 * @returns {Function} Fonction wrapp√©e avec gestion d'erreurs
 *
 * @example
 * // Sans asyncHandler (verbeux)
 * app.get('/users', async (req, res, next) => {
 *   try {
 *     const users = await getUsers();
 *     res.json(users);
 *   } catch (error) {
 *     next(error);
 *   }
 * });
 *
 * @example
 * // Avec asyncHandler (propre)
 * app.get('/users', asyncHandler(async (req, res) => {
 *   const users = await getUsers();
 *   res.json(users);
 * }));
 */
export const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

/**
 * @function handleSpecificErrors
 * @description Middleware de mapping d'erreurs techniques vers erreurs business
 *
 * Fonction r√©volutionnaire qui transforme les erreurs techniques (MongoDB
 * PostgreSQL, JWT, etc.) en erreurs applicatives avec messages clairs
 * et codes HTTP appropri√©s
 *
 * **Types d'Erreurs G√©r√©es:**
 * - MongoDB: CastError, ValidationError, Duplicate Key (11000)
 * - PostgreSQL: Unique violation (23505), Foreign key (23503), Not null (23502)
 * - JWT: JsonWebTokenError, TokenExpiredError
 * - Autres: Types d'erreurs techniques courantes
 *
 * @param {Error} err - Erreur technique √† mapper
 * @param {Object} req - Requ√™te Express
 * @param {Object} res - R√©ponse Express
 * @param {Function} next - Fonction next Express
 *
 * @example
 * // Configuration Express (avant globalErrorHandler)
 * app.use(handleSpecificErrors);
 * app.use(globalErrorHandler);
 */
export const handleSpecificErrors = (err, req, res, next) => {
  // MongoDB/Mongoose errors
  if (err.name === 'CastError') {
    const message = `Invalid ${err.path}: ${err.value}`;
    err = new ValidationError(message);
  }

  // MongoDB duplicate key error
  if (err.code === 11000) {
    const value = err.errmsg.match(/(["'])(\\?.)*?\1/)[0];
    const message = `Duplicate field value: ${value}. Please use another value`;
    err = new ConflictError(message);
  }

  // MongoDB validation error
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(val => val.message);
    const message = `Invalid input data. ${errors.join('. ')}`;
    err = new ValidationError(message);
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    const message = 'Invalid token. Please log in again';
    err = new AuthenticationError(message);
  }

  if (err.name === 'TokenExpiredError') {
    const message = 'Your token has expired. Please log in again';
    err = new AuthenticationError(message);
  }

  // PostgreSQL errors
  if (err.code === '23505') { // Unique violation
    const message = 'Duplicate value detected. Resource already exists';
    err = new ConflictError(message);
  }

  if (err.code === '23503') { // Foreign key violation
    const message = 'Referenced resource does not exist';
    err = new ValidationError(message);
  }

  if (err.code === '23502') { // Not null violation
    const message = 'Required field is missing';
    err = new ValidationError(message);
  }

  next(err);
};

/**
 * @function notFoundHandler
 * @description Handler pour routes non trouv√©es (404)
 *
 * Middleware r√©volutionnaire qui capture toutes les requ√™tes vers
 * des routes non d√©finies et g√©n√®re une erreur NotFoundError
 * appropri√©e avec le chemin demand√©
 *
 * @param {Object} req - Requ√™te Express
 * @param {Object} res - R√©ponse Express
 * @param {Function} next - Fonction next Express
 *
 * @example
 * // Configuration Express (en dernier)
 * app.use(notFoundHandler);
 */
export const notFoundHandler = (req, res, next) => {
  const message = `Route ${req.originalUrl} not found`;
  next(new NotFoundError(message));
};

/**
 * @function generateRequestId
 * @description G√©n√®re un ID unique pour tra√ßabilit√© des requ√™tes
 *
 * @returns {string} ID al√©atoire alphanumm√©rique de 9 caract√®res
 * @private
 */
const generateRequestId = () => {
  return (crypto.randomBytes(4).readUInt32BE(0) / 0xFFFFFFFF).toString(36).substr(2, 9);
};

/**
 * @function healthCheckError
 * @description Gestionnaire d'erreurs sp√©cialis√© pour health checks
 *
 * @param {Error} error - Erreur de health check
 * @param {string} service - Nom du service en erreur
 * @returns {ExternalServiceError} Erreur format√©e
 *
 * @example
 * const dbError = healthCheckError(error, 'PostgreSQL');
 */
export const healthCheckError = (error, service) => {
  logger.error(`Health check failed for ${service}`, {
    service
    error: error.message
    timestamp: new Date().toISOString()
  });

  return new ExternalServiceError(service, error);
};

/**
 * @function databaseErrorHandler
 * @description Gestionnaire d'erreurs sp√©cialis√© pour op√©rations base de donn√©es
 *
 * Fonction r√©volutionnaire qui mappe les erreurs de base de donn√©es
 * (connexion, timeout, etc.) vers des erreurs applicatives appropri√©es
 *
 * @param {Error} error - Erreur de base de donn√©es
 * @param {string} operation - Op√©ration qui a √©chou√©
 * @returns {AppError|ExternalServiceError} Erreur format√©e
 *
 * @example
 * const dbError = databaseErrorHandler(error, 'user creation');
 */
export const databaseErrorHandler = (error, operation) => {
  logger.error(`Database operation failed: ${operation}`, {
    error: error.message
    operation
    timestamp: new Date().toISOString()
  });

  // Map database errors to appropriate HTTP errors
  if (error.code === 'ECONNREFUSED') {
    return new ExternalServiceError('Database', error);
  }

  if (error.code === 'ETIMEDOUT') {
    return new ExternalServiceError('Database timeout', error);
  }

  return new AppError(`Database operation failed: ${operation}`, 500, false);
};

/**
 * @function aiServiceErrorHandler
 * @description Gestionnaire d'erreurs sp√©cialis√© pour services IA ALEX
 *
 * Fonction r√©volutionnaire qui g√®re les erreurs des services IA
 * (OpenAI, Claude, mod√®les locaux) avec logging sp√©cialis√©
 *
 * @param {Error} error - Erreur du service IA
 * @param {string} service - Nom du service IA
 * @returns {ExternalServiceError} Erreur format√©e
 *
 * @example
 * const aiError = aiServiceErrorHandler(error, 'OpenAI GPT-4');
 */
export const aiServiceErrorHandler = (error, service) => {
  logger.error(`AI service error: ${service}`, {
    error: error.message
    service
    timestamp: new Date().toISOString()
  });

  return new ExternalServiceError(`AI Service: ${service}`, error);
};

/**
 * @function validateSchema
 * @description Middleware de validation Joi avec formatage d'erreurs
 *
 * Fonction r√©volutionnaire qui cr√©e un middleware Express pour
 * validation Joi avec transformation erreurs en ValidationError
 * structur√©e et nettoyage automatique des donn√©es
 *
 * @param {Object} schema - Sch√©ma Joi pour validation
 * @returns {Function} Middleware Express de validation
 *
 * @example
 * import { userSchemas } from '../config/validation.js';
 * app.post('/users', validateSchema(userSchemas.create), createUser);
 */
export const validateSchema = (schema) => {
  return (req, res, next) => {
    const { error, value } = schema.validate(req.body, {
      abortEarly: false
      allowUnknown: false
      stripUnknown: true
    });

    if (error) {
      const details = error.details.reduce((acc, detail) => {
        acc[detail.path.join('.')] = detail.message;
        return acc;
      }, {});

      return next(new ValidationError('Validation failed', details));
    }

    req.validatedBody = value;
    next();
  };
};

/**
 * @function requestTimeout
 * @description Middleware de timeout pour requ√™tes longues
 *
 * Fonction r√©volutionnaire qui ajoute timeout automatique aux requ√™tes
 * avec cleanup automatique des timers pour √©viter les memory leaks
 *
 * @param {number} [timeoutMs=30000] - Timeout en millisecondes (d√©faut 30s)
 * @returns {Function} Middleware Express de timeout
 *
 * @example
 * // Timeout global de 10 secondes
 * app.use(requestTimeout(10000));
 *
 * @example
 * // Timeout sp√©cifique pour route lourde
 * app.post('/ai/analyze', requestTimeout(60000), analyzeData);
 */
export const requestTimeout = (timeoutMs = 30000) => {
  return (req, res, next) => {
    const timeout = setTimeout(() => {
      const error = new AppError('Request timeout', 408);
      next(error);
    }, timeoutMs);

    res.on('finish', () => {
      clearTimeout(timeout);
    });

    res.on('close', () => {
      clearTimeout(timeout);
    });

    next();
  };
};

export default {
  AppError
  ValidationError
  AuthenticationError
  AuthorizationError
  NotFoundError
  ConflictError
  RateLimitError
  ExternalServiceError
  globalErrorHandler
  handleSpecificErrors
  notFoundHandler
  asyncHandler
  healthCheckError
  databaseErrorHandler
  aiServiceErrorHandler
  validateSchema
  requestTimeout
};